<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>MoviePilot Top7 Poster Stack</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, monospace;
    }
    canvas {
      background: linear-gradient(#1c1c1e, #000);
    }
  </style>
</head>
<body>

<canvas id="c" width="800" height="400"></canvas>

<script>
/* =======================
   é…ç½®
   ======================= */
const { MP_BASE_URL, MP_TOKEN, TMDB_KEY } = window.__ENV__;

// ğŸ”’ è·¯å¾„å†™æ­»åœ¨å‰ç«¯æ¨¡æ¿
const MP_API =
  `${MP_BASE_URL}/api/v1/subscribe/list?token=${encodeURIComponent(MP_TOKEN)}`;



const CANDIDATE_LIMIT = 20;
const FINAL_LIMIT = 7;

/* =======================
   å·¥å…·
   ======================= */
function toDate(d) {
  if (!d) return null;
  const x = new Date(d);
  x.setHours(0,0,0,0);
  return x;
}

/* ======================================================
   IndexedDB poster cache
   ====================================================== */
const DB_NAME = "poster_cache_db";
const STORE_NAME = "posters";
const DB_VERSION = 1;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);

    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME);
      }
    };

    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function getFromCache(key) {
  const db = await openDB();
  return new Promise(resolve => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => resolve(null);
  });
}

async function saveToCache(key, blob) {
  const db = await openDB();
  return new Promise(resolve => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    store.put(blob, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => resolve();
  });
}

/* ======================================================
   å¸¦ç¼“å­˜çš„å›¾ç‰‡åŠ è½½ï¼ˆæµè§ˆå™¨ç‰ˆ â‰ˆ Scriptableï¼‰
   ====================================================== */
async function loadImage(src) {
  // 1ï¸âƒ£ å…ˆå°è¯• fetchï¼ˆç”¨äºç¼“å­˜ï¼‰
  try {
    const res = await fetch(src, { mode: "cors" });
    if (res.ok) {
      const blob = await res.blob();
      return await createImageBitmap(blob);
    }
  } catch {}

  // 2ï¸âƒ£ CORS æ‹¦æˆªæ—¶ï¼Œé€€å› <img>
  return new Promise(resolve => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = () => resolve(null);
    img.src = src;
  });
}




function drawRoundedImage(ctx, img, x, y, w, h, r) {
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(img, x, y, w, h);
  ctx.restore();
}
function daysFromToday(airDate) {
  if (!airDate) return null;

  // airDate é€šå¸¸æ˜¯ "YYYY-MM-DD"ã€‚
  // ç›´æ¥ new Date("YYYY-MM-DD") ä¼šæŒ‰ UTC è§£æï¼Œå¯¼è‡´åœ¨ +08 ç­‰æ—¶åŒºå‡ºç°è·¨å¤©åå·®ã€‚
  // è¿™é‡Œæ”¹ä¸ºâ€œæŒ‰æœ¬åœ°æ—¥æœŸâ€è§£æï¼Œä¿è¯â€œä»Šæ—¥/æ˜å¤©/åå¤©â€çš„è®¡ç®—åœ¨å®¹å™¨æœ¬åœ°æ—¶åŒºä¸‹ç¨³å®šã€‚
  const m = String(airDate).match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (!m) return null;
  const y = Number(m[1]);
  const mo = Number(m[2]);
  const da = Number(m[3]);

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const d = new Date(y, mo - 1, da);
  d.setHours(0, 0, 0, 0);

  return Math.round((d - today) / 86400000);
}

function timeLabel(airDate) {
  const diff = daysFromToday(airDate);
  if (diff === null) return "å¾…å®š";
  if (diff === 0) return "ä»Šæ—¥";
  if (diff === 1) return "æ˜å¤©";
  if (diff === 2) return "åå¤©";
  if (diff > 2) return `${diff}å¤©å`;
  return "å·²æ’­";
}
/* =======================
   API
   ======================= */
async function fetchSubscribeList() {
  const res = await fetch(MP_API);
  const text = await res.text();
  if (!res.ok) throw new Error(text);
  return JSON.parse(text);
}

async function fetchTvDetails(tmdbid) {
  const res = await fetch(
    `https://api.themoviedb.org/3/tv/${tmdbid}?api_key=${TMDB_KEY}&language=zh-CN`
  );
  const data = await res.json();
  return {
    airDate: data?.next_episode_to_air?.air_date || null,
    originCountry: data?.origin_country || [],
    firstAirDate: data?.first_air_date || null
  };
}

/* =======================
   æƒé‡åˆ†è®¡ç®—
   ======================= */
function getCountryScore(originCountry) {
  if (!Array.isArray(originCountry) || originCountry.length === 0) {
    return 0;
  }
  
  // æ£€æŸ¥æ˜¯å¦åŒ…å«æŒ‡å®šå›½å®¶/åœ°åŒºä»£ç 
  const hasCountry = (codes) => originCountry.some(c => codes.includes(c));
  
  // CN,TW,HK = 5åˆ†
  if (hasCountry(['CN', 'TW', 'HK'])) return 8;
  
  // US,FR,GB,DE,ES,IT,NL,PT,RU,UK = 10åˆ†
  if (hasCountry(['US', 'FR', 'GB', 'DE', 'ES', 'IT', 'NL', 'PT', 'RU', 'UK'])) return 10;
  
  // JP,KP,KR,TH,IN,SG = 8åˆ†
  if (hasCountry(['JP', 'KP', 'KR', 'TH', 'IN', 'SG'])) return 9;
  
  return 0;
}

function calculateScore(item) {
  let score = 0;
  
  // 1. åœ°åŒºæƒé‡åˆ†
  score += getCountryScore(item.originCountry);
  
  // 2. è¿½å‰§ä¸­ï¼š10åˆ†ï¼Œå¦åˆ™0åˆ†
  if (item.isFollowing) {
    score += 10;
  }
  
  // 3. vote åˆ†æ•°
  score += (item.vote || 0);
  
  // 4. æ­£åœ¨æ’­æ”¾ï¼š10åˆ†ï¼ˆfirst_air_date < ä»Šå¤© ä¸” å­˜åœ¨ airDateï¼‰
  if (item.firstAirDate && item.airDate) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const firstAir = toDate(item.firstAirDate);
    if (firstAir && firstAir < today) {
      score += 10;
    }
  }
  
  return score;
}

/* =======================
   æ ¸å¿ƒå–æ•°é€»è¾‘ï¼ˆæƒé‡åˆ†ç‰ˆæœ¬ï¼‰
   ======================= */
async function getTop7() {
  const subs = await fetchSubscribeList();

  // åªè¦ç”µè§†å‰§ä¸”æœ‰ tmdbid
  const tvSubs = subs.filter(
    s => s.type === "ç”µè§†å‰§" && s.tmdbid
  );

  // è·å–æ‰€æœ‰å‰§é›†çš„è¯¦ç»†ä¿¡æ¯ï¼ˆairDate + originCountryï¼‰
  const enriched = [];
  for (const s of tvSubs) {
    const details = await fetchTvDetails(s.tmdbid);
    const isFollowing = 
      typeof s.total_episode === "number" &&
      typeof s.lack_episode === "number" &&
      (s.total_episode - s.lack_episode) > 0;
    
    const item = {
      name: s.name,
      poster: s.poster,
      vote: s.vote || 0,
      isFollowing,
      airDate: details.airDate,
      originCountry: details.originCountry,
      firstAirDate: details.firstAirDate
    };
    
    // è®¡ç®—æƒé‡åˆ†
    item.score = calculateScore(item);
    enriched.push(item);
  }

  // æŒ‰æƒé‡åˆ†æ’åºï¼ˆé™åºï¼‰ï¼Œå–å‰7
  enriched.sort((a, b) => b.score - a.score);
  const top7 = enriched.slice(0, FINAL_LIMIT);

  // æœ€åæŒ‰æ’­å‡ºæ—¶é—´æ’åºï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
  top7.sort((a, b) => {
    if (a.airDate && b.airDate)
      return toDate(a.airDate) - toDate(b.airDate);
    if (a.airDate) return -1;
    if (b.airDate) return 1;
    return 0;
  });

  return top7;
}

/* =======================
   ç”Ÿæˆå›¾ç‰‡
   ======================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const CARD_W = 180;
const CARD_H = 270;
const GAP_X = 20;
const GAP_Y = 20;
const RADIUS = 20;
const SHADOW_X = 4;
const SHADOW_Y = 6;
const ROTATE = 15 * Math.PI / 180;

const HALF_SHIFT = CARD_H / 2;
const COL_Y_OFFSET = {
  0: -HALF_SHIFT,
  1: 0,
  2: HALF_SHIFT
};

async function buildGrid(images) {
  const grid = document.createElement("canvas");
  grid.width = 3 * CARD_W + 2 * GAP_X;
  grid.height = 3 * CARD_H + 2 * GAP_Y + CARD_H;
  const gctx = grid.getContext("2d");

  let idx = 0;
  const drawCard = (col, baseY) => {
    if (idx >= images.length) return;
    const img = images[idx++];
    if (!img) return;
    const x = col * (CARD_W + GAP_X);
    const y = baseY + COL_Y_OFFSET[col];
    gctx.fillStyle = "rgba(0,0,0,0.25)";
    gctx.fillRect(x + SHADOW_X, y + SHADOW_Y, CARD_W, CARD_H);
    drawRoundedImage(gctx, img, x, y, CARD_W, CARD_H, RADIUS);
  };

  drawCard(1, 0); drawCard(2, 0);
  drawCard(0, CARD_H + GAP_Y);
  drawCard(1, CARD_H + GAP_Y);
  drawCard(2, CARD_H + GAP_Y);
  drawCard(0, 2 * (CARD_H + GAP_Y));
  drawCard(1, 2 * (CARD_H + GAP_Y));

  return grid;
}
function drawLeftText(list) {
  const START_X = 30;
  const START_Y = 65;
  const LINE_H = 50;
  const MAX_LINES = 6;

  const maxAlpha = 1.0;
  const minAlpha = 0.3;
  const step =
    (maxAlpha - minAlpha) / (MAX_LINES - 1);

  ctx.font = "24px 'Inter', 'Noto Sans CJK SC', sans-serif";
  ctx.textBaseline = "top";

  list.slice(0, MAX_LINES).forEach((item, i) => {
    const y = START_Y + i * LINE_H;
    const alpha = maxAlpha - i * step;

    // æ—¶é—´æ ‡ç­¾ï¼ˆç¨å¾®æ›´æ·¡ä¸€ç‚¹ï¼‰
    ctx.fillStyle = `rgba(255,255,255,${alpha * 0.8})`;
    ctx.fillText(
      timeLabel(item.airDate),
      START_X,
      y
    );

    // å‰§åï¼ˆä¸»ä½“ï¼‰
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillText(
      item.name,
      START_X + 80,
      y
    );
  });
}

async function renderPosters(top7) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (!top7.length) return;
  // ğŸ”¥ å·¦ä¾§æ–‡å­—
  drawLeftText(top7);
  const images = (await Promise.all(
    top7.map(s => loadImage(s.poster))
  )).filter(Boolean);

  if (!images.length) return;

  const grid = await buildGrid(images);
  const CENTER_COL_X =
    (CARD_W + GAP_X) * 1 + CARD_W / 2;

  ctx.save();
  ctx.translate(
    canvas.width - CENTER_COL_X + 50,
    canvas.height / 2 + 140
  );
  ctx.rotate(ROTATE);
  ctx.drawImage(
    grid,
    -CENTER_COL_X,
    -grid.height / 2
  );
  ctx.restore();
}

/* =======================
   å¯åŠ¨
   ======================= */
(async () => {
  try {
    const top7 = await getTop7();
    await renderPosters(top7);
  } catch (e) {
    console.error("RENDER FAILED", e);
  } finally {
    // â­ å‘Šè¯‰æœåŠ¡ç«¯ï¼šcanvas å·²ç»ç”»å®Œï¼ˆä¸ç®¡æˆåŠŸä¸å¦ï¼‰
    window.__RENDER_DONE__ = true;
  }
})();
</script>

</body>
</html>
